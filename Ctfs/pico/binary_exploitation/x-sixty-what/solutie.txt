Deschizand programul cu gef putem folosi comanda inf function pentru a vedea adresele de inceput ale tuturor functiilor din vuln, deoarece binarul nu a fost stripped(s-au pastrat simbolurile). 
Astfel vedem adresa de inceput a functiei flag: 0x0000000000401236
Ruland programul in gef si introducand un pattern de 200 de caractere facut cu comanda pattern create 200(din gef)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
obtinem un seg fault si putem astfel sa vedem ce registri am suprascris si ce nu am suprascris. Se observa ca instruction pointerul nu s-a modificat, iar asta e din cauza ca arhitectura pe 64 biti are canonical values care sunt acceptate in ip:
canonical address refers to one in the range 0x0000000000000000 to 0x00007FFFFFFFFFFF and 0xFFFF800000000000 to 0xFFFFFFFFFFFFFFFF. Any address outside this range is non-canonical.
Astfel trebuie sa cautam offsetul la care se afla RSP cu comanda pattern search $rsp (din modul debug al gef dupa ce am dat seg fault la program) si obtinem offset-ul 72
Preluam scriptul de la ctf-ul bufferoverflow1 si il modificam pentru a suprascrie la offset-ul 72 adresa functiei flag. Vom transmite doar 6 bytes(si nu 8 cat o adresa intreaga in arhitectura pe 64 biti) in plus fata de offset-ul 72, pentru ca restul sa fie padding de 0 si sa obtinem o adresa canonica (de genul 0x00007FFFFFFFFFFF)
Ruland comanda:
python3 -c "import sys; sys.stdout.buffer.write(b'a'*72+b'\x36\x12\x40')" | ./vuln
putem observa ca am ajuns in functia flag deoarece obtinem outputul:
Welcome to 64-bit. Give me a string that gets you the flag: 
Please create 'flag.txt' in this directory with your own debugging flag.

Acum incercam acelasi lucru remote prin nc folosind scriptul in python

Observam ca ruland script-ul in python nu mai obtinem acelasi rezultat. Acest lucru se datoreaza instructiunii endbr64 de la inceputul functiei flag. Intel o descrie astfel:
The ENDBRANCH (see Section 73 for details) is a new instruction that is used to mark valid jump target addresses of indirect calls and jumps in the program. This instruction opcode is selected to be one that is a NOP on legacy machines such that programs compiled with ENDBRANCH new instruction continue to function on old machines without the CET enforcement. On processors that support CET the ENDBRANCH is still a NOP and is primarily used as a marker instruction by the processor pipeline to detect control flow violations. The CPU implements a state machine that tracks indirect jmp and call instructions. When one of these instructions is seen, the state machine moves from IDLE to WAIT_FOR_ENDBRANCH state. In WAIT_FOR_ENDBRANCH state the next instruction in the program stream must be an ENDBRANCH. If an ENDBRANCH is not seen the processor causes a control protection exception (#CP), else the state machine moves back to IDLE state.

Practic nu putem face un jump unintended by default la inceputul acestei functii. Vom incerca totusi sa facem jump la urmatoarele instructiuni a caror adresa o putem vedea cu comanda 'disas flag' din gef
0x0000000000401236 <+0>:     endbr64 
0x000000000040123a <+4>:     push   rbp
0x000000000040123b <+5>:     mov    rbp,rsp
0x000000000040123e <+8>:     sub    rsp,0x50

Incercand pe rand adresele observam ca obtinem flag-ul atunci cand facem jump la adresa 0x000000000040123b

picoCTF{b1663r_15_b3773r_be31178c}