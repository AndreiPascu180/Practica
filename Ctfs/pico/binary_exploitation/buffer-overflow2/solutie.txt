Am realizat un script foloind libraria pwn(modulul pwntools) si logica programului este astfel:
Ne folosim de executabilul dat pentru a identifica adresa functiei de interes(win) - stiind ca acesta e numele functiei din codul sursa vuln.c.
Folosind gef putem rula executabilul vuln si sa ii transmitem un sir suficient de lung de caractere ca sa primim un seg fault, apoi putem folosi comanda pattern search $eip pentru a gasi offsetul la care se gaseste registrul eip sa stim unde trebuie sa incarcam adresa functiei win.
Construim payload-ul ajutandu-ne de functionalitatile librariei pwn (cu p32 practic avem implenetata functionalitatea librariei struct cu functiile pack pentru a transforma o adresa in little endian). Din modul in care construim payload-ul vom incarca stiva in sens invers al citirii ei, deci argumentele care trebuie verificate pentru a obtine flagg-ul le punem ultimele.
Astfel la citirea stivei vor fi parcurse in ordine: eip, return address, arg1, arg 2(ca si cum ar fi fost facut push arg2 si apoi push arg1)
Apoi ne folosim de functia remote din pwn (in loc sa mai folosim libraria socket) pentru a folosi argumentele comenzii de rulare a scriptului ca host si port la care transmitem payload-ul si afisand ce primim din aceasta conexiune vom primi si flag-ul
picoCTF{argum3nt5_4_d4yZ_4b24a3aa} 